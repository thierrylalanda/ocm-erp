{
  "version": 3,
  "sources": ["src/app/modules/manage-users/domain/repositories/user.repository.ts"],
  "sourcesContent": ["import { Injectable, InjectionToken } from '@angular/core';\nimport { User, UserId, UserCreateCommand, UserUpdateCommand, UserResponse, UsersPagedResponse } from '../entities/user.entity';\nimport { PaginationOptions } from '../types/paged-response.type';\n\n/**\n * Token d'injection pour UserRepository\n */\nexport const USER_REPOSITORY = new InjectionToken<UserRepository>('UserRepository');\n\n/**\n * Interface du repository pour la gestion des utilisateurs\n */\nexport interface UserRepository {\n  // Opérations CRUD de base\n  findById(id: UserId): Promise<User | null>;\n  findByEmail(email: string): Promise<User | null>;\n  findByUsername(username: string): Promise<User | null>;\n  \n  // Récupération paginée\n  findAllPaginated(options?: PaginationOptions): Promise<UsersPagedResponse>;\n  \n  // Création et mise à jour\n  create(user: User): Promise<User>;\n  update(user: User): Promise<User>;\n  delete(id: UserId): Promise<void>;\n  \n  // Opérations métier\n  activateUser(id: UserId): Promise<User>;\n  deactivateUser(id: UserId): Promise<User>;\n  recordLogin(id: UserId): Promise<void>;\n  \n  // Recherche et filtrage\n  searchUsers(query: string, options?: PaginationOptions): Promise<UsersPagedResponse>;\n  findByStatus(status: string, options?: PaginationOptions): Promise<UsersPagedResponse>;\n  findBySite(siteId: number, options?: PaginationOptions): Promise<UsersPagedResponse>;\n  findByDepartment(departmentId: number, options?: PaginationOptions): Promise<UsersPagedResponse>;\n  findBySociete(societeId: number, options?: PaginationOptions): Promise<UsersPagedResponse>;\n  \n  // Validation\n  existsByEmail(email: string): Promise<boolean>;\n  existsByUsername(username: string): Promise<boolean>;\n  \n  // Opérations en masse\n  createMany(users: User[]): Promise<User[]>;\n  updateMany(users: User[]): Promise<User[]>;\n}\n\n/**\n * Options de requête pour le repository\n */\nexport interface UserRepositoryQueryOptions extends PaginationOptions {\n  status?: string;\n  siteId?: number;\n  departmentId?: number;\n  societeId?: number;\n}\n\n/**\n * Résultat de recherche d'utilisateurs\n */\nexport interface UserRepositorySearchResult {\n  users: User[];\n  total: number;\n  hasMore: boolean;\n  currentPage: number;\n  totalPages: number;\n}\n\n/**\n * Repository de base abstrait\n */\nexport abstract class BaseUserRepository implements UserRepository {\n  abstract findById(id: UserId): Promise<User | null>;\n  abstract findByEmail(email: string): Promise<User | null>;\n  abstract findByUsername(username: string): Promise<User | null>;\n  abstract findAllPaginated(options?: PaginationOptions): Promise<UsersPagedResponse>;\n  abstract create(user: User): Promise<User>;\n  abstract update(user: User): Promise<User>;\n  abstract delete(id: UserId): Promise<void>;\n  abstract activateUser(id: UserId): Promise<User>;\n  abstract deactivateUser(id: UserId): Promise<User>;\n  abstract recordLogin(id: UserId): Promise<void>;\n  abstract searchUsers(query: string, options?: PaginationOptions): Promise<UsersPagedResponse>;\n  abstract findByStatus(status: string, options?: PaginationOptions): Promise<UsersPagedResponse>;\n  abstract findBySite(siteId: number, options?: PaginationOptions): Promise<UsersPagedResponse>;\n  abstract findByDepartment(departmentId: number, options?: PaginationOptions): Promise<UsersPagedResponse>;\n  abstract findBySociete(societeId: number, options?: PaginationOptions): Promise<UsersPagedResponse>;\n  abstract existsByEmail(email: string): Promise<boolean>;\n  abstract existsByUsername(username: string): Promise<boolean>;\n  abstract createMany(users: User[]): Promise<User[]>;\n  abstract updateMany(users: User[]): Promise<User[]>;\n  \n  // Méthodes étendues\n  async findWithOptions(options: UserRepositoryQueryOptions): Promise<UserRepositorySearchResult> {\n    const response = await this.findAllPaginated(options);\n    \n    return {\n      users: response.content.map(userResponse => this.mapResponseToUser(userResponse)),\n      total: response.totalElements,\n      hasMore: response.page < response.totalPages - 1,\n      currentPage: response.page,\n      totalPages: response.totalPages\n    };\n  }\n  \n  async countByStatus(status: string): Promise<number> {\n    const response = await this.findByStatus(status);\n    return response.totalElements;\n  }\n  \n  async countBySite(siteId: number): Promise<number> {\n    const response = await this.findBySite(siteId);\n    return response.totalElements;\n  }\n  \n  async countByDepartment(departmentId: number): Promise<number> {\n    const response = await this.findByDepartment(departmentId);\n    return response.totalElements;\n  }\n  \n  async findActiveUsers(options?: PaginationOptions): Promise<UsersPagedResponse> {\n    return this.findByStatus('ACTIF', options);\n  }\n  \n  async findInactiveUsers(options?: PaginationOptions): Promise<UsersPagedResponse> {\n    return this.findByStatus('INACTIF', options);\n  }\n  \n  // Méthode de mapping protégée pour les implémentations concrètes\n  protected abstract mapResponseToUser(response: UserResponse): User;\n  protected abstract mapUserToCreateCommand(user: User): UserCreateCommand;\n  protected abstract mapUserToUpdateCommand(user: User): UserUpdateCommand;\n}\n"],
  "mappings": ";;;;;;;;;;AAAA,IAOa,iBAgES;AAvEtB;;;;AAOO,IAAM,kBAAkB,IAAI,eAA+B,gBAAgB;AAgE5E,IAAgB,qBAAhB,MAAkC;;MAsBhC,gBAAgB,SAAmC;;AACvD,gBAAM,WAAW,MAAM,KAAK,iBAAiB,OAAO;AAEpD,iBAAO;YACL,OAAO,SAAS,QAAQ,IAAI,kBAAgB,KAAK,kBAAkB,YAAY,CAAC;YAChF,OAAO,SAAS;YAChB,SAAS,SAAS,OAAO,SAAS,aAAa;YAC/C,aAAa,SAAS;YACtB,YAAY,SAAS;;QAEzB;;MAEM,cAAc,QAAc;;AAChC,gBAAM,WAAW,MAAM,KAAK,aAAa,MAAM;AAC/C,iBAAO,SAAS;QAClB;;MAEM,YAAY,QAAc;;AAC9B,gBAAM,WAAW,MAAM,KAAK,WAAW,MAAM;AAC7C,iBAAO,SAAS;QAClB;;MAEM,kBAAkB,cAAoB;;AAC1C,gBAAM,WAAW,MAAM,KAAK,iBAAiB,YAAY;AACzD,iBAAO,SAAS;QAClB;;MAEM,gBAAgB,SAA2B;;AAC/C,iBAAO,KAAK,aAAa,SAAS,OAAO;QAC3C;;MAEM,kBAAkB,SAA2B;;AACjD,iBAAO,KAAK,aAAa,WAAW,OAAO;QAC7C;;;;;",
  "names": []
}
